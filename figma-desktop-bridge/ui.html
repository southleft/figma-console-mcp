<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #ffffff;
      color: #1a1a1a;
      padding: 24px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .container {
      max-width: 320px;
      width: 100%;
    }

    .status {
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon {
      font-size: 16px;
      line-height: 1;
    }

    .details {
      font-size: 12px;
      color: #666;
      line-height: 1.6;
      margin-top: 8px;
    }

    .details strong {
      color: #1a1a1a;
      font-weight: 500;
    }

    .success {
      color: #059669;
    }

    .error {
      color: #dc2626;
    }

    .loading {
      color: #6b7280;
    }

    .divider {
      height: 1px;
      background: #e5e7eb;
      margin: 16px 0;
    }

    .footer {
      font-size: 11px;
      color: #9ca3af;
      margin-top: 16px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="content">
      <div class="status loading">
        <span class="icon">⏳</span>
        <span>Loading data...</span>
      </div>
      <div class="details">Connecting to Figma API</div>
    </div>
    <div class="divider"></div>
    <div class="footer">Made with ❤️ by Southleft</div>
  </div>

  <script>
    // Global variables to store data for Puppeteer access
    window.__figmaVariablesData = null;
    window.__figmaVariablesReady = false;
    window.__figmaComponentData = null;
    window.__figmaComponentRequests = new Map(); // Track pending requests
    window.__figmaPendingRequests = new Map(); // Track ALL pending requests (generic)

    let requestIdCounter = 0;

    // Generic function to send a command to the plugin worker and wait for response
    window.sendPluginCommand = (type, params, timeoutMs) => {
      timeoutMs = timeoutMs || 15000;
      return new Promise((resolve, reject) => {
        const requestId = `${type.toLowerCase()}_${++requestIdCounter}_${Date.now()}`;

        // Timeout - store the ID so we can clear it when response arrives
        const timeoutId = setTimeout(() => {
          if (window.__figmaPendingRequests.has(requestId)) {
            window.__figmaPendingRequests.delete(requestId);
            reject(new Error(type + ' request timed out after ' + timeoutMs + 'ms'));
          }
        }, timeoutMs);

        // Store the promise callbacks AND the timeout ID for cleanup
        window.__figmaPendingRequests.set(requestId, { resolve, reject, type: type, timeoutId: timeoutId });

        // Build the message
        const message = Object.assign({ type: type, requestId: requestId }, params || {});

        // Send request to plugin worker
        parent.postMessage({ pluginMessage: message }, '*');

        console.log('[Desktop Bridge] Sent command:', type, 'requestId:', requestId);
      });
    };

    // ============================================================================
    // WRITE OPERATION FUNCTIONS - Exposed for Puppeteer/MCP access
    // ============================================================================

    // Execute arbitrary code in plugin context
    // Returns { success: true, result: ... } or { success: false, error: "..." }
    // Never rejects - always returns a plain object for puppeteer BiDi compatibility
    window.executeCode = (code, timeout) => {
      return window.sendPluginCommand('EXECUTE_CODE', { code: code, timeout: timeout || 5000 }, (timeout || 5000) + 2000)
        .catch(function(err) {
          // Convert rejection to plain object for BiDi serialization
          return { success: false, error: err.message || String(err) };
        });
    };

    // Update a variable's value
    window.updateVariable = (variableId, modeId, value) => {
      return window.sendPluginCommand('UPDATE_VARIABLE', { variableId: variableId, modeId: modeId, value: value })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Create a new variable
    window.createVariable = (name, collectionId, resolvedType, options) => {
      var params = {
        name: name,
        collectionId: collectionId,
        resolvedType: resolvedType
      };
      if (options) {
        if (options.valuesByMode) params.valuesByMode = options.valuesByMode;
        if (options.description) params.description = options.description;
        if (options.scopes) params.scopes = options.scopes;
      }
      return window.sendPluginCommand('CREATE_VARIABLE', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Create a new variable collection
    window.createVariableCollection = (name, options) => {
      var params = { name: name };
      if (options) {
        if (options.initialModeName) params.initialModeName = options.initialModeName;
        if (options.additionalModes) params.additionalModes = options.additionalModes;
      }
      return window.sendPluginCommand('CREATE_VARIABLE_COLLECTION', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Delete a variable
    window.deleteVariable = (variableId) => {
      return window.sendPluginCommand('DELETE_VARIABLE', { variableId: variableId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Delete a variable collection
    window.deleteVariableCollection = (collectionId) => {
      return window.sendPluginCommand('DELETE_VARIABLE_COLLECTION', { collectionId: collectionId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Rename a variable
    window.renameVariable = (variableId, newName) => {
      return window.sendPluginCommand('RENAME_VARIABLE', { variableId: variableId, newName: newName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Add a mode to a collection
    window.addMode = (collectionId, modeName) => {
      return window.sendPluginCommand('ADD_MODE', { collectionId: collectionId, modeName: modeName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Rename a mode in a collection
    window.renameMode = (collectionId, modeId, newName) => {
      return window.sendPluginCommand('RENAME_MODE', { collectionId: collectionId, modeId: modeId, newName: newName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Refresh variables data
    window.refreshVariables = () => {
      return window.sendPluginCommand('REFRESH_VARIABLES', {})
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Get all local components for design system manifest
    // Large design systems with many pages can take several minutes to process
    window.getLocalComponents = () => {
      return window.sendPluginCommand('GET_LOCAL_COMPONENTS', {}, 300000)  // 5 minute timeout for large files
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Instantiate a component with overrides
    window.instantiateComponent = (componentKey, options) => {
      return window.sendPluginCommand('INSTANTIATE_COMPONENT', {
        componentKey: componentKey,
        nodeId: options?.nodeId,  // For local (unpublished) components
        position: options?.position,
        size: options?.size,
        overrides: options?.overrides,
        variant: options?.variant,
        parentId: options?.parentId
      })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Function to request component data from plugin worker (legacy, kept for compatibility)
    window.requestComponentData = (nodeId) => {
      return new Promise((resolve, reject) => {
        const requestId = `component_${++requestIdCounter}_${Date.now()}`;

        // Store the promise callbacks
        window.__figmaComponentRequests.set(requestId, { resolve, reject });

        // Send request to plugin worker
        parent.postMessage({
          pluginMessage: {
            type: 'GET_COMPONENT',
            requestId: requestId,
            nodeId: nodeId
          }
        }, '*');

        console.log('[Desktop Bridge] Requested component:', nodeId, 'requestId:', requestId);

        // Timeout after 10 seconds
        setTimeout(() => {
          if (window.__figmaComponentRequests.has(requestId)) {
            window.__figmaComponentRequests.delete(requestId);
            reject(new Error('Component request timed out'));
          }
        }, 10000);
      });
    };

    // Listen for messages from plugin worker
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;

      if (msg.type === 'VARIABLES_DATA') {
        // Store data on window object for Puppeteer
        window.__figmaVariablesData = msg.data;
        window.__figmaVariablesReady = true;

        const varCount = msg.data.variables?.length || 0;
        const collCount = msg.data.variableCollections?.length || 0;

        // Update UI
        document.getElementById('content').innerHTML = `
          <div class="status success">
            <span class="icon">✓</span>
            <span>Desktop Bridge active</span>
          </div>
          <div class="details">
            <strong>Variables:</strong> ${varCount} in ${collCount} ${collCount === 1 ? 'collection' : 'collections'}<br>
            <strong>Components:</strong> On-demand via MCP<br>
            <strong>Write ops:</strong> Enabled ✓<br>
            <br>
            <code style="font-size: 10px; background: #f3f4f6; padding: 2px 6px; border-radius: 4px; display: block; margin-top: 4px;">window.executeCode(code)</code>
            <code style="font-size: 10px; background: #f3f4f6; padding: 2px 6px; border-radius: 4px; display: block; margin-top: 2px;">window.updateVariable(id, mode, val)</code>
          </div>
        `;

        console.log('[Desktop Bridge] Variables ready:', { varCount, collCount });

      } else if (msg.type === 'COMPONENT_DATA') {
        // Store component data
        window.__figmaComponentData = msg.data;

        console.log('[Desktop Bridge] Component data received:', msg.data.component.name);

        // Resolve the promise
        const request = window.__figmaComponentRequests.get(msg.requestId);
        if (request) {
          request.resolve(msg.data);
          window.__figmaComponentRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'COMPONENT_ERROR') {
        console.error('[Desktop Bridge] Component error:', msg.error);

        // Reject the promise
        const request = window.__figmaComponentRequests.get(msg.requestId);
        if (request) {
          request.reject(new Error(msg.error));
          window.__figmaComponentRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'ERROR') {
        window.__figmaVariablesReady = false;

        document.getElementById('content').innerHTML = `
          <div class="status error">
            <span class="icon">✕</span>
            <span>Error loading data</span>
          </div>
          <div class="details">${msg.error}</div>
        `;

        console.error('[Desktop Bridge] Error:', msg.error);

      // ============================================================================
      // WRITE OPERATION RESPONSES - Handle results from plugin worker
      // ============================================================================

      } else if (msg.type === 'EXECUTE_CODE_RESULT') {
        console.log('[Desktop Bridge] Execute code result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, result: msg.result });
          } else {
            // Return a plain object instead of rejecting with Error for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'UPDATE_VARIABLE_RESULT') {
        console.log('[Desktop Bridge] Update variable result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, variable: msg.variable });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'CREATE_VARIABLE_RESULT') {
        console.log('[Desktop Bridge] Create variable result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, variable: msg.variable });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'CREATE_VARIABLE_COLLECTION_RESULT') {
        console.log('[Desktop Bridge] Create collection result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, collection: msg.collection });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'DELETE_VARIABLE_RESULT') {
        console.log('[Desktop Bridge] Delete variable result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, deleted: msg.deleted });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'DELETE_VARIABLE_COLLECTION_RESULT') {
        console.log('[Desktop Bridge] Delete collection result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, deleted: msg.deleted });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'REFRESH_VARIABLES_RESULT') {
        console.log('[Desktop Bridge] Refresh variables result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, data: msg.data });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'RENAME_VARIABLE_RESULT') {
        console.log('[Desktop Bridge] Rename variable result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, variable: msg.variable, oldName: msg.oldName });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'ADD_MODE_RESULT') {
        console.log('[Desktop Bridge] Add mode result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, collection: msg.collection, newMode: msg.newMode });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'RENAME_MODE_RESULT') {
        console.log('[Desktop Bridge] Rename mode result:', msg.success ? 'success' : 'error', msg.error || '');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          // Clear timeout to prevent memory leak
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, collection: msg.collection, oldName: msg.oldName });
          } else {
            // Return plain object instead of rejecting for BiDi compatibility
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'GET_LOCAL_COMPONENTS_RESULT') {
        console.log('[Desktop Bridge] Get local components result:', msg.success ? 'success' : 'error');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, data: msg.data });
          } else {
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }

      } else if (msg.type === 'INSTANTIATE_COMPONENT_RESULT') {
        console.log('[Desktop Bridge] Instantiate component result:', msg.success ? 'success' : 'error');
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            request.resolve({ success: true, instance: msg.instance });
          } else {
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }
      }
    };
  </script>
</body>
</html>
